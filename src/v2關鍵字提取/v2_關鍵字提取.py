# -*- coding: utf-8 -*-
"""v1_SQLite_ç´€éŒ„.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cXnrwCNnIW8X8B6hwzwK75arPFKXGCMk

##æ›è¼‰ Google Drive
"""

from google.colab import drive
drive.mount('/content/drive')

"""##åŠ å…¥å°ˆæ¡ˆè·¯å¾‘"""

import os
import sys

# æ‚¨çš„å°ˆæ¡ˆåœ¨ Google Drive ä¸­çš„è·¯å¾‘
PROJECT_PATH = '/content/drive/MyDrive/projects/LINE BOT'

# æ‚¨è¦æª¢æŸ¥çš„æª”æ¡ˆåç¨±
FILE_CHECK_NAME = 'v_2_keyword_extractor.py'

# çµ„åˆå®Œæ•´çš„æª”æ¡ˆè·¯å¾‘
FILE_CHECK_PATH = os.path.join(PROJECT_PATH, FILE_CHECK_NAME)

# --- è¨ºæ–·é‚è¼¯ ---
if os.path.exists(FILE_CHECK_PATH):
    print(f"âœ… è¨ºæ–·æˆåŠŸï¼šæ–‡ä»¶ '{FILE_CHECK_NAME}' å­˜åœ¨æ–¼ {PROJECT_PATH}ã€‚")

    # åƒ…åœ¨è·¯å¾‘å°šæœªåŠ å…¥æ™‚æ‰åŠ å…¥ï¼Œä»¥é¿å…é‡è¤‡
    if PROJECT_PATH not in sys.path:
        sys.path.append(PROJECT_PATH)
        print(f"âœ… å·²å°‡è·¯å¾‘åŠ å…¥ç³»çµ±æœå°‹æ¸…å–®ã€‚")
else:
    # å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œç«‹å³åœæ­¢ä¸¦å ±å‘ŠéŒ¯èª¤
    print(f"âŒ è¨ºæ–·å¤±æ•—ï¼šæ–‡ä»¶ '{FILE_CHECK_NAME}' ä¸å­˜åœ¨æ–¼ {PROJECT_PATH}ã€‚")
    print("è«‹ä»”ç´°æª¢æŸ¥ Google Drive ä¸Šçš„è³‡æ–™å¤¾åç¨±æ˜¯å¦æœ‰éš±è—çš„ç©ºæ ¼æˆ–ç¬¦è™Ÿã€‚")
    raise FileNotFoundError("è·¯å¾‘æˆ–æª”æ¡ˆåç¨±éŒ¯èª¤ï¼Œç„¡æ³•ç¹¼çºŒã€‚")
# --- è¨ºæ–·çµæŸ ---

"""##1) å®‰è£å¥—ä»¶ï¼ˆæŒ‡å®šç‰ˆæœ¬ç¯„åœï¼‹ç”¨é€”è¨»è§£ï¼‰"""

# Colab Cell (å®‰è£å¥—ä»¶)

# 1. å®‰è£ LINE Bot SDK v3
!pip install "line-bot-sdk>=3.0.0,<4.0.0"

# 2. å®‰è£ Flask
!pip install "Flask>=3.0.0,<4.0.0"

# 3. å®‰è£ pyngrok
!pip install "pyngrok>=7.0.0,<8.0.0"

# 4. Jieba: ä¸­æ–‡åˆ†è©åº« (ç”¨æ–¼ TF-IDF æå–)
!pip install "jieba>=0.42"

"""##2) é–‹ ngrokï¼ˆå…ˆåŸ·è¡Œé€™ä¸€æ ¼æ‹¿åˆ°å…¬é–‹ç¶²å€ï¼‰"""

from pyngrok import ngrok

# æ›æˆä½ è‡ªå·±çš„ ngrok authtoken
NGROK_AUTHTOKEN = "ä½ çš„å¯†ç¢¼"   # ä¾‹ï¼š2pEWt4...ï¼ˆä¸è¦å…¬é–‹åœ¨ GitHubï¼‰
PORT = 5000

# è¨­å®šé‡‘é‘°
ngrok.set_auth_token(NGROK_AUTHTOKEN)

# é—œé–‰èˆŠéš§é“ï¼ˆé¿å…é‡è¤‡ï¼‰
for t in ngrok.get_tunnels():
    ngrok.disconnect(t.public_url)

# å»ºç«‹æ–°éš§é“ï¼Œå–å¾—å…¬é–‹ HTTPS ç¶²å€
public_url = ngrok.connect(PORT, "http").public_url

print("ğŸ‘‰ å¤–ç¶²ç¶²å€ï¼š", public_url)
print("Webhook URLï¼š", public_url + "/callback")

"""##3) LINE Bot ç¨‹å¼"""

#å¾Line bot sdk pyplç¶²ç«™æ‰¾åˆ°ç¨‹å¼ç¢¼è²¼ä¸Š
#https://pypi.org/project/line-bot-sdk/
import os
import sys
import re
import json # ğŸŒŸ æ–°å¢ï¼šç”¨æ–¼è™•ç†é—œéµè©çš„ JSON æ ¼å¼ ğŸŒŸ
from flask import Flask, request, abort

from v1_sqlite_dataseat import (
    init_db,
    insert_log,
    close_db,
    get_user_log_count,
    # ğŸŒŸ ä¿®æ­£ï¼šå°å…¥æ‰€æœ‰éœ€è¦çš„ CRUD å‡½å¼ ğŸŒŸ
    get_latest_log,
    get_first_log,
    get_nth_log,
    delete_all_logs,
    delete_log_by_id,
    get_all_logs_summary
)

from linebot.v3 import (
    WebhookHandler
)
from linebot.v3.exceptions import (
    InvalidSignatureError
)
from linebot.v3.messaging import (
    Configuration,
    ApiClient,
    MessagingApi,
    ReplyMessageRequest,
    TextMessage
)
from linebot.v3.webhooks import (
    MessageEvent,
    TextMessageContent
)

# 1. å°å…¥æ‚¨çš„è³‡æ–™åº«å‡½å¼
from v1_sqlite_dataseat import (
    # ... (åŸæœ‰ DB å‡½å¼)
    get_all_logs_summary
)

# ğŸŒŸ V2 é—œéµå­—æå–ï¼šå°å…¥æ–°çš„åˆ†æå‡½å¼ ğŸŒŸ
from v_2_keyword_extractor import extract_keywords_tfidf
# -----------------------------------------------


app = Flask(__name__)

# æ†‘è­‰è¨­å®šï¼šè«‹æ›¿æ›æˆæ‚¨çš„ LINE Bot æ†‘è­‰
CHANNEL_ACCESS_TOKEN = os.environ.get('LINE_ACCESS_TOKEN', 'YOUR_LINE_ACCESS_TOKEN')
CHANNEL_SECRET = os.environ.get('LINE_CHANNEL_SECRET', 'YOUR_LINE_CHANNEL_SECRET')

configuration = Configuration(access_token=CHANNEL_ACCESS_TOKEN)
handler = WebhookHandler(CHANNEL_SECRET)

# ğŸŒŸ æ•¸æ“šåº«å„ªåŒ–ï¼šè¨»å†Šè³‡æ–™åº«é—œé–‰å‡½å¼ ğŸŒŸ
# ç¢ºä¿æ¯å€‹è«‹æ±‚çµæŸå¾Œéƒ½æœƒé—œé–‰é€£ç·šï¼Œé‡‹æ”¾è³‡æº
app.teardown_appcontext(close_db)

QUERY_PATTERN = re.compile(r'^(?:ç¬¬\s*|æŸ¥è©¢\s*ç¬¬?\s*)(\d+)\s*ç¯‡?') # æŸ¥è©¢ç¬¬ N ç¯‡
DELETE_ALL_PATTERN = re.compile(r'^(?:åˆªé™¤æ‰€æœ‰|æ¸…é™¤æ‰€æœ‰|/clear|/delete\s*all)$', re.I) # åˆªé™¤æ‰€æœ‰
DELETE_ID_PATTERN = re.compile(r'^(?:åˆªé™¤\s*ID|delete\s*id)\s*[:ï¼š]?\s*(\d+)$', re.I) # åˆªé™¤ ID

@app.route("/callback", methods=['POST'])
def callback():
    signature = request.headers['X-Line-Signature']
    body = request.get_data(as_text=True)
    app.logger.info("Request body: " + body)

    try:
        handler.handle(body, signature)
    except InvalidSignatureError:
        app.logger.info("Invalid signature. Please check your channel access token/channel secret.")
        abort(400)

    return 'OK'

@handler.add(MessageEvent, message=TextMessageContent)
def handle_message(event):
    user_id = event.source.user_id
    user_input = event.message.text.strip()
    reply_text = None

    # ğŸŒŸ æ–°å¢ï¼šäºŒæ¬¡ç¢ºèªçš„é—œéµè¨Šæ¯ ğŸŒŸ
    CONFIRM_DELETE_MSG = "è«‹å†æ¬¡è¼¸å…¥ã€ç¢ºå®šåˆªé™¤ã€ä¾†æ¸…ç©ºæ‰€æœ‰æ—¥è¨˜ã€‚"
    # ----------------------------------------------------
    # A. è™•ç†ã€Œåˆªé™¤ã€æŒ‡ä»¤
    # ----------------------------------------------------
    # 1. è™•ç†ã€Œç¢ºèªåˆªé™¤ã€å›è¦†ï¼ˆåªæœ‰åœ¨æ”¶åˆ°é€™å€‹é—œéµå­—æ™‚æ‰åŸ·è¡Œæ¸…ç©ºï¼‰
    if user_input == "ç¢ºå®šåˆªé™¤":
        # æª¢æŸ¥ä½¿ç”¨è€…æ˜¯å¦å‰›å‰›è¢«è¦æ±‚ç¢ºèªï¼ˆé›–ç„¶ç°¡å–®ï¼Œä½†åœ¨å–®ä¸€æµç¨‹ä¸­æœ‰æ•ˆï¼‰
        # é€™è£¡æˆ‘å€‘ä¿¡ä»»ä½¿ç”¨è€…åªæœ‰åœ¨è¢«è¦æ±‚æ™‚æ‰æœƒè¼¸å…¥ 'ç¢ºå®šåˆªé™¤'
        deleted_count = delete_all_logs(user_id)
        if deleted_count > 0:
            reply_text = (
                f"ğŸ—‘ï¸ è­¦å‘Šï¼šå·²æˆåŠŸåˆªé™¤æ‚¨å…± {deleted_count} ç¯‡æ—¥è¨˜ï¼æ‚¨çš„ç´€éŒ„å·²æ¸…ç©ºã€‚\n"
                f"ç¾åœ¨æ‚¨å¯ä»¥é‡æ–°é–‹å§‹å¯«æ—¥è¨˜äº†ï¼"
            )
        else:
            # å¯èƒ½æ˜¯èª¤è§¸ï¼Œæˆ–è€…æœ¬ä¾†å°±æ²’æœ‰ç´€éŒ„
            reply_text = "æ‚¨çš„æ—¥è¨˜åº«ä¸­æ²’æœ‰ä»»ä½•ç´€éŒ„å¯ä»¥åˆªé™¤ï¼Œä¸éœ€è¦é€²è¡Œæ¸…ç©ºæ“ä½œã€‚"

    # 2. è™•ç†ã€Œåˆªé™¤ IDã€æŒ‡ä»¤
    elif (match := DELETE_ID_PATTERN.match(user_input.lower())):
        log_id_to_delete = int(match.group(1))

        if delete_log_by_id(log_id_to_delete):
            total_logs = get_user_log_count(user_id)
            reply_text = (
                f"ğŸ—‘ï¸ å·²æˆåŠŸåˆªé™¤å”¯ä¸€ ID ç‚º {log_id_to_delete} çš„ç´€éŒ„ï¼\n"
                f"ç›®å‰æ‚¨é‚„å‰©ä¸‹ {total_logs} ç¯‡æ—¥è¨˜ã€‚"
            )
        else:
            reply_text = f"æ‰¾ä¸åˆ° ID ç‚º {log_id_to_delete} çš„ç´€éŒ„å¯ä¾›åˆªé™¤ï¼Œæˆ–è©²ç´€éŒ„ä¸å±¬æ–¼æ‚¨ã€‚"

    # 3. è™•ç†ã€Œè«‹æ±‚åˆªé™¤æ‰€æœ‰ã€æŒ‡ä»¤ (è§¸ç™¼äºŒæ¬¡ç¢ºèª)
    elif DELETE_ALL_PATTERN.match(user_input.lower()):
        total_logs = get_user_log_count(user_id)
        if total_logs == 0:
            reply_text = "æ‚¨çš„æ—¥è¨˜åº«ä¸­æ²’æœ‰ä»»ä½•ç´€éŒ„å¯ä»¥åˆªé™¤ã€‚"
        else:
            # ğŸŒŸ é—œéµï¼šè¦æ±‚äºŒæ¬¡ç¢ºèª ğŸŒŸ
            reply_text = (
                f"âš ï¸ **æ‚¨ç¢ºå®šè¦åˆªé™¤æ‰€æœ‰ {total_logs} ç¯‡æ—¥è¨˜å—ï¼Ÿ**\n"
                f"æ­¤æ“ä½œä¸å¯å¾©åŸï¼\n\n"
                f"{CONFIRM_DELETE_MSG}"
            )


    # ----------------------------------------------------
    # B. è™•ç†ã€Œæ¸…å–®/é è¦½æ‰€æœ‰ã€æŒ‡ä»¤ (List/Preview All)
    # ----------------------------------------------------
    elif user_input.lower() in ['/list', 'æ¸…å–®', 'é è¦½æ‰€æœ‰']:
        summaries = get_all_logs_summary(user_id)
        total_logs = len(summaries)

        if total_logs > 0:
            list_items = []
            # i æ˜¯å¾ 0 é–‹å§‹çš„ç´¢å¼•
            for i, (log_id, date_part, summary) in enumerate(summaries):
                # é¡¯ç¤ºæ ¼å¼: [ç·¨è™Ÿ] (æ—¥æœŸ) ID: XXX | æ‘˜è¦å…§å®¹
                list_items.append(
                    f"[{i+1}] ({date_part}) ID:{log_id} | {summary}"
                )

            reply_text = (
                f"ğŸ“ æ‚¨çš„æ—¥è¨˜æ¸…å–® (å…± {total_logs} ç¯‡)ï¼š\n"
                f"--------------------------------------\n"
                + "\n".join(list_items) +
                f"\n--------------------------------------\n"
                f"å¯è¼¸å…¥ã€åˆªé™¤ ID: XXXã€æˆ–ã€ç¬¬ N ç¯‡ã€é€²è¡Œæ“ä½œã€‚\n"
                f"å¦‚éœ€å…¨éƒ¨åˆªé™¤ï¼Œè«‹è¼¸å…¥ã€åˆªé™¤æ‰€æœ‰ã€ã€‚"
            )
        else:
            reply_text = "æ‚¨çš„æ—¥è¨˜åº«ä¸­æ²’æœ‰ä»»ä½•ç´€éŒ„å–”ï¼"

    # ----------------------------------------------------
    # C. è™•ç†ã€ŒæŸ¥è©¢å–®ç¯‡ã€æŒ‡ä»¤ (Latest/First/Nth)
    # ----------------------------------------------------

    # åªæœ‰åœ¨ reply_text ä»ç‚º None æ™‚ï¼Œæ‰é€²å…¥æŸ¥è©¢é‚è¼¯
    elif reply_text is None:
        log = None
        title = None
        n = None

        if user_input.lower() in ['/last', 'æœ€å¾Œä¸€ç¯‡', 'æŸ¥è©¢æœ€æ–°']:
            log = get_latest_log(user_id)
            title = "æœ€æ–°"

        elif user_input.lower() in ['/first', 'ç¬¬ä¸€ç¯‡', 'æŸ¥è©¢æœ€æ—©']:
            log = get_first_log(user_id)
            title = "ç¬¬ä¸€ç¯‡"

        elif (match := QUERY_PATTERN.match(user_input)):
            n = int(match.group(1))
            log = get_nth_log(user_id, n)
            title = f"ç¬¬ {n}"

        # çµ„åˆæŸ¥è©¢å–®ç¯‡çµæœçš„å›è¦† (é è¦½åŠŸèƒ½)
        if log:
            log_id, log_text = log # ğŸŒŸ è§£æ§‹å…ƒçµ„ï¼Œç²å¾— ID å’Œå…§å®¹ ğŸŒŸ
            reply_text = (
                f"ğŸ“œ æ‚¨å¯«ä¸‹çš„**{title}**ç´€éŒ„æ˜¯ï¼š\n"
                f"ğŸ‘‰ å”¯ä¸€ ID: {log_id} ğŸ‘ˆ\n"
                f"--------------------\n"
                f"ã€Œ{log_text}ã€\n"
                f"--------------------\n"
                f"å¦‚éœ€åˆªé™¤æ­¤ç¯‡ï¼Œè«‹è¼¸å…¥ï¼š åˆªé™¤ ID: {log_id}"
            )
        elif title: # å‘½ä¸­äº†æŸ¥è©¢æŒ‡ä»¤ï¼Œä½†æ²’æ‰¾åˆ°ç´€éŒ„
            total_logs = get_user_log_count(user_id)
            if total_logs > 0 and n:
                reply_text = f"ç›®å‰æ‚¨åªå¯«äº† {total_logs} ç¯‡ç´€éŒ„ï¼Œç„¡æ³•æŸ¥è©¢ç¬¬ {n} ç¯‡ã€‚"
            elif total_logs == 0:
                reply_text = "æ‚¨é‚„æ²’æœ‰å¯«éä»»ä½•ç´€éŒ„å–”ï¼"

    # ----------------------------------------------------
    # D. è™•ç†ã€Œå¯«æ—¥è¨˜ã€æŒ‡ä»¤ (å¦‚æœä¸æ˜¯ä»»ä½•æŒ‡ä»¤ï¼Œå‰‡å„²å­˜)
    # ----------------------------------------------------
    if reply_text is None:

        # ğŸŒŸ V2 é—œéµå­—æå–ï¼šå‘¼å« TF-IDF å‡½å¼ ğŸŒŸ
        # 1. æå–é—œéµè©ï¼Œå¾—åˆ° JSON æ ¼å¼å­—ä¸²
        extracted_keywords_json = extract_keywords_tfidf(user_input)

        # 2. å„²å­˜æ—¥è¨˜ï¼Œå°‡é—œéµè©å‚³å…¥
        # insert_log å‡½å¼å·²æ”¯æ´ keywords æ¬„ä½
        insert_log(
            user_id=user_id,
            raw_text=user_input,
            keywords=extracted_keywords_json # ğŸŒŸ å‚³å…¥ V2 çµæœ ğŸŒŸ
        )
        total_logs = get_user_log_count(user_id)

        # 3. åœ¨å›è¦†ä¸­é¡¯ç¤ºæå–çµæœ (éœ€è¦ json.loads è½‰æ›å›ä¾†é¡¯ç¤º)
        try:
            # å°‡ JSON å­—ä¸²è§£ç¢¼å› Python åˆ—è¡¨ for é¡¯ç¤º
            keywords_display = json.loads(extracted_keywords_json)
        except json.JSONDecodeError:
            keywords_display = ["æå–å¤±æ•—æˆ–æ ¼å¼éŒ¯èª¤"]

        # 4. çµ„åˆå›è¦†
        reply_text = (
            f"ğŸ“ æ‚¨çš„ç´€éŒ„å·²æˆåŠŸæ”¶éŒ„ï¼\n"
            f"ã€Œé€™æ˜¯æ‚¨å¯«ä¸‹çš„ç¬¬ {total_logs} ç¯‡ç´€éŒ„ã€‚ã€\n"
            f"ğŸ”‘ ç³»çµ±æå–çš„é—œéµè©ï¼š{keywords_display} \n"
            f" â¤ï¸æˆ‘å€‘æœƒæº«æŸ”åœ°ç‚ºæ‚¨ä¿ç®¡é€™ä»½çè²´çš„å›æ†¶ã€‚\n"
            f"ğŸ‘‰è¼¸å…¥ã€æ¸…å–®ã€å³å¯é è¦½æ‰€æœ‰ç´€éŒ„æ¸…å–®ï¼"
        )

    # ----------------------------------------------------
    # E. å›è¦†ä½¿ç”¨è€…
    # ----------------------------------------------------
    with ApiClient(configuration) as api_client:
        line_bot_api = MessagingApi(api_client)
        line_bot_api.reply_message_with_http_info(
            ReplyMessageRequest(
                reply_token=event.reply_token,
                messages=[TextMessage(text=reply_text)]
            )
        )

if __name__ == "__main__":
    # æ‡‰ç”¨ç¨‹å¼å•Ÿå‹•å‰ï¼Œå…ˆåˆå§‹åŒ–è³‡æ–™åº«
    init_db()

    # é‹è¡Œ Flask æœå‹™
    app.run(port=5000)