# -*- coding: utf-8 -*-
"""v1_sqlite_dataseat.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZeQ0CMo2tAJpJLZlJ_L-p_1IzTjpR26J
"""

# -*- coding: utf-8 -*-
"""v1_SQLite_dataseat.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17pEn55UZQDyh7UUPS2cwXva78Jx0Aumx
"""

from flask import g
from datetime import datetime, timedelta
import sqlite3
import os

# ----------------------------------------------------
# 💡 數據持久化設定：Google Drive 路徑
# ----------------------------------------------------
# 請確保您在 Colab 中已經執行了：from google.colab import drive; drive.mount('/content/drive')
# 這個路徑是 Colab 虛擬機存取您 Google Drive 的標準入口
DRIVE_BASE_PATH = '/content/drive/MyDrive/projects/'

# 建議：將資料庫放在您 Drive 內的一個專屬資料夾
# 您可以將 'LineBot_Data' 替換為任何您喜歡的資料夾名稱
PROJECT_DATA_FOLDER = 'LineBot_Data'

# 最終資料庫檔案的完整路徑
DB_DIR = os.path.join(DRIVE_BASE_PATH, PROJECT_DATA_FOLDER)
DB_NAME = os.path.join(DB_DIR, 'emotion_diary.db')
# ----------------------------------------------------


def get_db():
    """獲取資料庫連線。確保在單個請求中只連線一次。"""
    if 'db' not in g:
        g.db = sqlite3.connect(DB_NAME)
        g.db.row_factory = sqlite3.Row
    return g.db


def close_db(e=None):
    """關閉資料庫連線，在 Flask 請求結束時會被呼叫。"""
    db = g.pop('db', None)
    if db is not None:
        db.close()


def init_db():
    """初始化資料庫：建立資料夾與資料表"""

    # 🌟 關鍵：如果資料夾不存在，就創建它 🌟
    if not os.path.exists(DB_DIR):
        print(f"資料夾不存在，正在創建: {DB_DIR}")
        os.makedirs(DB_DIR)

    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()

    # 建立資料表，包含 V1 到 V3 所有需要的欄位
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS diary_logs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id TEXT NOT NULL,
            timestamp TEXT NOT NULL,
            raw_text TEXT,
            sentiment TEXT,
            score REAL,
            keywords TEXT
        )
    ''')
    conn.commit()
    conn.close()
    print(f"✅ 資料庫 {DB_NAME} 初始化完成，資料將永久儲存在 Google Drive 上。")


def insert_log(user_id, raw_text, sentiment='Neutral', score=0.0, keywords='[]'):
    """將日記記錄存入資料庫 (使用 g.db 連線)。"""
    db = get_db()
    current_time = datetime.now().isoformat()
    db.execute(
        """
        INSERT INTO diary_logs
        (user_id, timestamp, raw_text, sentiment, score, keywords)
        VALUES (?, ?, ?, ?, ?, ?)
        """,
        (user_id, current_time, raw_text, sentiment, score, keywords)
    )
    db.commit()


def get_user_log_count(user_id):
    """查詢使用者總共寫了多少篇日記。"""
    db = get_db()
    result = db.execute(
        "SELECT COUNT(id) FROM diary_logs WHERE user_id = ?",
        (user_id,)
    ).fetchone()
    # fetchone() 返回的是一個 tuple，取第一個元素就是數量
    return result[0] if result else 0


def get_latest_log(user_id):
    """查詢特定用戶的最新一篇日記內容及 ID。"""
    db = get_db()
    try:
        sql = """
            SELECT id, raw_text  -- 🌟 修正：加入 id 欄位 🌟
            FROM diary_logs 
            WHERE user_id = ? 
            ORDER BY timestamp DESC  
            LIMIT 1
        """
        result = db.execute(sql, (user_id,)).fetchone()

        if result:
            # 🌟 修正：返回 (id, raw_text) 元組 🌟
            return (result[0], result[1])
        else:
            return None
    except Exception as e:
        print(f"查詢最新日記時發生錯誤: {e}")
        return None


def get_first_log(user_id):
    """查詢特定用戶的第一篇（最舊的）日記內容及 ID。"""
    db = get_db()
    try:
        sql = """
            SELECT id, raw_text  -- 🌟 修正：加入 id 欄位 🌟
            FROM diary_logs 
            WHERE user_id = ? 
            ORDER BY timestamp ASC  
            LIMIT 1
        """
        result = db.execute(sql, (user_id,)).fetchone()

        if result:
            # 🌟 修正：返回 (id, raw_text) 元組 🌟
            return (result[0], result[1])
        else:
            return None
    except Exception as e:
        print(f"查詢第一篇日記時發生錯誤: {e}")
        return None


def get_nth_log(user_id, n):
    """查詢特定用戶的第 n 篇日記內容及 ID。"""
    db = get_db()
    if n < 1:
        return None
    offset = n - 1

    try:
        sql = """
            SELECT id, raw_text  -- 🌟 修正：加入 id 欄位 🌟
            FROM diary_logs 
            WHERE user_id = ? 
            ORDER BY timestamp ASC  
            LIMIT 1 
            OFFSET ?              
        """
        result = db.execute(sql, (user_id, offset)).fetchone()

        if result:
            # 🌟 修正：返回 (id, raw_text) 元組 🌟
            return (result[0], result[1])
        else:
            return None

    except Exception as e:
        print(f"查詢第 {n} 篇日記時發生錯誤: {e}")
        return None


def get_all_logs_summary(user_id):
    """
    查詢特定用戶的所有日記紀錄的 ID、時間戳和內容摘要。（已實現清單預覽功能）

    Returns:
        list of tuples: [(id, date_part, summary), ...] 或空列表。
    """
    db = get_db()

    try:
        sql = """
            SELECT id, timestamp, raw_text 
            FROM diary_logs 
            WHERE user_id = ? 
            ORDER BY timestamp ASC
        """
        results = db.execute(sql, (user_id,)).fetchall()

        summary_list = []
        for row in results:
            log_id = row['id']
            timestamp = row['timestamp']
            raw_text = row['raw_text']

            # 格式化時間戳
            date_part = timestamp.split(
                'T')[0] if 'T' in timestamp else timestamp.split(' ')[0]

            # 截斷內容
            summary = raw_text[:20] + ('...' if len(raw_text) > 20 else '')

            summary_list.append((log_id, date_part, summary))

        return summary_list

    except Exception as e:
        print(f"查詢所有日記清單時發生錯誤: {e}")
        return []

# ----------------------------------------------------
# C. 更新 (Update) - 新增
# ----------------------------------------------------


def update_log_by_id(log_id, new_raw_text):
    """
    根據日記的唯一 ID 更新其原始內容 (raw_text) 和 timestamp。

    Args:
        log_id (int): 要更新的日記的唯一 ID (INTEGER)。
        new_raw_text (str): 日記的新內容。

    Returns:
        int: 受影響的行數 (1 表示成功，0 表示失敗)。
    """
    db = get_db()

    # 📝 注意：這裡同時更新內容和時間戳 (timestamp)，表示內容有變動。
    sql = """
        UPDATE diary_logs
        SET raw_text = ?, timestamp = ?
        WHERE id = ?
    """
    current_time = datetime.now().isoformat()

    try:
        # 使用參數化查詢，防止 SQL 注入
        cursor = db.execute(sql, (new_raw_text, current_time, log_id))
        db.commit()
        return cursor.rowcount  # 返回受影響的行數 (期望是 1)
    except Exception as e:
        print(f"更新 ID {log_id} 的日記時發生錯誤: {e}")
        db.rollback()
        return 0

# ----------------------------------------------------
# D. 刪除 (Delete)
# ----------------------------------------------------


def delete_all_logs(user_id):
    """刪除特定用戶的所有日記紀錄。"""
    db = get_db()
    try:
        cursor = db.execute(
            "DELETE FROM diary_logs WHERE user_id = ?", (user_id,))
        deleted_count = cursor.rowcount
        db.commit()
        return deleted_count
    except Exception as e:
        print(f"刪除所有日記時發生錯誤: {e}")
        return 0


def delete_nth_log(user_id, n):
    """
    刪除特定用戶的第 n 篇日記。
    （保留此函式以支援舊有邏輯，但建議使用 delete_log_by_id 更精準）
    """
    db = get_db()

    if n < 1:
        return False
    offset = n - 1

    select_id_sql = """
        SELECT id 
        FROM diary_logs 
        WHERE user_id = ? 
        ORDER BY timestamp ASC  
        LIMIT 1 
        OFFSET ?
    """

    try:
        result = db.execute(select_id_sql, (user_id, offset)).fetchone()

        if result:
            log_id = result[0]
            delete_sql = "DELETE FROM diary_logs WHERE id = ?"
            cursor = db.execute(delete_sql, (log_id,))

            db.commit()
            return cursor.rowcount > 0
        else:
            return False

    except Exception as e:
        print(f"刪除第 {n} 篇日記時發生錯誤: {e}")
        return False


def delete_log_by_id(user_id, log_id_to_delete):
    """
    根據使用者 ID 和日記的唯一 ID 刪除單篇日記。
    這確保使用者只能刪除自己的日記，並且是精準刪除的關鍵。
    """
    db = get_db()

    try:
        # 🌟 修正 1 (安全性)：SQL 語句必須同時檢查 user_id 和 id，確保只能刪除自己的日記。
        # 修正 2 (變數)：將參數列表 (log_id,) 替換為 (user_id, log_id_to_delete)
        sql = "DELETE FROM diary_logs WHERE user_id = ? AND id = ?"
        cursor = db.execute(sql, (user_id, log_id_to_delete)) 
        
        db.commit()
        
        # 檢查是否有記錄被刪除 (如果 rowcount > 0 表示成功刪除)
        return cursor.rowcount > 0
        
    except Exception as e:
        # 🌟 修正 3 (變數)：將 print 語句中的 log_id 替換為 log_id_to_delete
        print(f"根據 ID {log_id_to_delete} 刪除日記時發生錯誤: {e}")
        return False


# ----------------------------------------------------
# E. V4 新增：每週彙整 (Retrieve Weekly Logs)
# ----------------------------------------------------

def get_weekly_logs(user_id, days=7):
    """
    查詢特定用戶過去 X 天的所有日記紀錄，用於每週總結。

    Args:
        user_id (str): 使用者的唯一 ID。
        days (int): 要查詢過去的天數 (預設為 7 天)。

    Returns:
        list of str: 過去 X 天的所有日記內容的列表。
    """
    # 獲取資料庫連線，使用 Flask 的 g
    db = get_db()

    # 🌟 計算起始時間 🌟
    # 計算 X 天前的時間，並轉換成 SQLite 儲存的 ISO 格式字串
    seven_days_ago = (datetime.now() - timedelta(days=days)).isoformat()

    try:
        sql = """
            SELECT raw_text
            FROM diary_logs 
            WHERE user_id = ? AND timestamp >= ? 
            ORDER BY timestamp ASC
        """
        # 執行查詢，過濾出時間戳大於七天前的紀錄
        # 注意：SQLite 會對 ISO 格式的 TEXT 進行正確的字串比較
        results = db.execute(sql, (user_id, seven_days_ago)).fetchall()

        # 將每一行的 'raw_text' 提取出來，組合成一個列表
        log_texts = [row['raw_text'] for row in results]

        return log_texts

    except Exception as e:
        print(f"查詢每週日記時發生錯誤: {e}")
        return []


if __name__ == '__main__':
    # 應用程式啟動時，初始化資料庫
    init_db()

    # ----------------------------------------------------
    # 🌟 UPDATE 功能單元測試 (修正版，不依賴 Flask g) 🌟
    # ----------------------------------------------------
    print("\n--- 執行 UPDATE 功能測試 ---")

    TEST_USER_ID = "update_test_user_id"
    conn = None  # 初始化本地連線變數

    try:
        # 建立一個獨立於 Flask 的本地資料庫連線進行測試
        conn = sqlite3.connect(DB_NAME)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        # 確保刪除上一次的殘留測試資料
        cursor.execute(
            "DELETE FROM diary_logs WHERE user_id = ?", (TEST_USER_ID,))

        # 插入一篇初始測試日記
        original_text = "這是原始的日記內容，我們將會把它更新。"
        current_time = datetime.now().isoformat()
        cursor.execute(
            "INSERT INTO diary_logs (user_id, timestamp, raw_text) VALUES (?, ?, ?)",
            (TEST_USER_ID, current_time, original_text)
        )
        conn.commit()

        # 獲取最新記錄的 ID 和內容
        cursor.execute(
            "SELECT id, raw_text FROM diary_logs WHERE user_id = ? ORDER BY timestamp DESC LIMIT 1",
            (TEST_USER_ID,)
        )
        latest_log = cursor.fetchone()

        if latest_log:
            log_id_to_update = latest_log['id']
            original_content_check = latest_log['raw_text']
            new_text = "✨ 成功更新！這就是我們用 UPDATE 寫入的新內容。"

            print(f"要更新的紀錄 ID: {log_id_to_update}")
            print(f"原始內容: {original_content_check[:20]}...")

            # 2. 執行 UPDATE 操作 (直接模擬 update_log_by_id 的 SQL)
            # 由於 update_log_by_id 依賴 get_db()，我們直接在這裡執行 SQL
            update_sql = """
                UPDATE diary_logs
                SET raw_text = ?, timestamp = ?
                WHERE id = ?
            """
            new_timestamp = datetime.now().isoformat()
            cursor.execute(
                update_sql, (new_text, new_timestamp, log_id_to_update))
            rows = cursor.rowcount
            conn.commit()

            # 3. 驗證結果
            cursor.execute(
                "SELECT id, raw_text FROM diary_logs WHERE user_id = ? ORDER BY timestamp DESC LIMIT 1",
                (TEST_USER_ID,)
            )
            updated_log = cursor.fetchone()

            if rows == 1 and updated_log and updated_log['raw_text'] == new_text:
                print(f"✅ 測試成功: 成功更新 {rows} 筆紀錄。")
                print(f"✅ 更新後內容 (摘要): {updated_log['raw_text'][:20]}...")
            else:
                print(f"❌ 測試失敗: 更新失敗或內容不匹配。受影響行數: {rows}")
        else:
            print("❌ 測試失敗：無法找到測試用的最新紀錄，請檢查 INSERT 是否成功。")

    except Exception as e:
        print(f"❌ 測試過程中發生錯誤: {e}")
    finally:
        # 4. 清理連線和測試資料 (只在本地連線存在時才操作)
        if conn:
            # 刪除測試資料
            conn.execute(
                "DELETE FROM diary_logs WHERE user_id = ?", (TEST_USER_ID,))
            conn.commit()
            conn.close()
            print("--- 測試資料已清理並關閉連線 ---")


# ... (所有的函式，包括 V4 的 get_weekly_logs)
    # ----------------------------------------------------
    # 🌟 V4 測試：測試 get_weekly_logs (新的追加在這裡) 🌟
    # ----------------------------------------------------
    print("\n--- 執行 V4 每週彙整功能測試 ---")

    # 假設您手動插入一些 TEST_USER_ID 的日記紀錄，確保有在 7 天內的資料
    V4_TEST_USER = "v4_weekly_test"
    conn = None

    try:
        conn = sqlite3.connect(DB_NAME)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        # 【清理】確保沒有舊的 V4 測試資料
        cursor.execute(
            "DELETE FROM diary_logs WHERE user_id = ?", (V4_TEST_USER,))
        conn.commit()

        # 【準備】插入兩篇今日的日記
        today = datetime.now().isoformat()
        cursor.execute("INSERT INTO diary_logs (user_id, timestamp, raw_text) VALUES (?, ?, ?)",
                       (V4_TEST_USER, today, "今天天氣很好，適合測試。"))
        cursor.execute("INSERT INTO diary_logs (user_id, timestamp, raw_text) VALUES (?, ?, ?)",
                       (V4_TEST_USER, today, "這是今天第二篇，應被撈出。"))
        conn.commit()

        # 【執行】使用 V4 函式的核心邏輯來測試
        seven_days_ago = (datetime.now() - timedelta(days=7)).isoformat()
        sql = "SELECT raw_text FROM diary_logs WHERE user_id = ? AND timestamp >= ? ORDER BY timestamp ASC"
        results = conn.execute(sql, (V4_TEST_USER, seven_days_ago)).fetchall()

        weekly_logs = [row['raw_text'] for row in results]

        # 【驗證】
        if len(weekly_logs) == 2:
            print(f"✅ V4 測試成功：找到 {len(weekly_logs)} 篇過去 7 天的日記。")
        else:
            print(f"❌ V4 測試失敗：預期 2 篇，但只找到 {len(weekly_logs)} 篇。")

    except Exception as e:
        print(f"❌ V4 測試過程中發生錯誤: {e}")
    finally:
        if conn:
            # 【清理】刪除 V4 測試資料
            conn.execute(
                "DELETE FROM diary_logs WHERE user_id = ?", (V4_TEST_USER,))
            conn.commit()
            conn.close()
            print("--- V4 測試連線已關閉 ---")
